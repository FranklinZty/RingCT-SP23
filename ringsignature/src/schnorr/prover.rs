use ark_ff::PrimeField;
use ark_serialize::CanonicalSerialize;
use ark_ec::CurveGroup;
use ark_std::{rand::Rng, UniformRand, end_timer, log2, start_timer, One, Zero};
use std::marker::PhantomData;

use crate::schnorr::transcript::ProofTranscript;
use crate::errors::{SchnorrErrors};
use crate::schnorr::pedersen::{Pedersen, Params};

// #[derive(Clone, Debug)]
// pub struct Proof<C: CurveGroup> {
//     cm: Commitment<C>,
//     U: C,
//     z: Vec<C::ScalarField>,
//     rz: C::ScalarField,
// }

#[derive(Clone, Debug)]
pub struct Schnorr<C: CurveGroup> {
    phantom: PhantomData<C>,
}

pub struct SchnorrProof<C: CurveGroup> {
    // the intermediate commitment vector generated along the proving
    pub commitments: Vec<C>,
    // the opening vector generated along the proving
    pub opening: Vec<C::ScalarField>,
    // the challenge vector generated by merlin transcript
    pub challenge: Vec<C::ScalarField>,
}

pub struct SchnorrParams<C: CurveGroup> {
    // the number of witness elements
    pub num_witness: usize,
    // the number of public inputs (commitments)
    pub num_pub_inputs: usize,
    // the generators for pedersen commitments
    pub generators: Params<C>,
}
/// Implement Schnorr signature by:
/// write the protocol step by step
/// calling the pedersen to generate elements
/// calling transcript for appending message and generate challenge
impl<C: CurveGroup> Schnorr<C> {
    /// Setup algorithm for Schnorr Signature
    /// Inputs:
    /// - rng: RngCore palys a role as the random tape
    /// - max: the maximum length of the witness supported
    /// Outputs:
    /// - Params<C>: Pedersen commitment parameter as a tuple (h, generators)
    ///
    pub fn setup<R: Rng>(
        rng: &mut R,
        max: usize
    ) -> Result<Params<C>, SchnorrErrors> {
        Ok(Pedersen::new_params(rng, max))
    }

    /// Prover algorithm for Schnorr Signature
    /// Inputs:
    /// - params: pedersen commitment parameter
    /// - pub_inputs: the commitment vector for witness
    /// - witness: the witness vector
    pub fn prove(
        params: &Params<C>,
        pub_inputs: &Vec<C>,
        witness: &Vec<C::ScalarField>,
    ) -> Result<Proof<C>, SchnorrErrors> {
        let start = start_timer!(|| "Schnorr siganture generating...");
        let mut transcript = ProofTranscript::<C::ScalarField>::new(b"SchnorrSignature");

        // z = m*r + u
        let cm = Pedersen::commit(params, m, r);
        let u = transcript.get_and_append_challenge_vectors(b"u", m.len()).unwrap();
        let ru = transcript.get_and_append_challenge(b"ru").unwrap();

        let msm = C::msm(&params.generators, &u).unwrap();
        let U = params.h.mul(ru) + msm;

        transcript.append_serializable_element(b"cm", &cm.0).unwrap();
        transcript.append_serializable_element(b"U", &U).unwrap();
        let c = transcript.get_and_append_challenge(b"c").unwrap();

        let z = m.iter().zip(u.iter()).map(|(mi, ui)| c * mi + ui).collect();
        let rz = c * r + ru;
        Proof {cm, U, z, rz }
    }

    pub fn verify(
        params: &Params<C>,
        transcript: &mut IOPTranscript<C::ScalarField>,
        proof: &Proof<C>,
    ) -> bool {
        // 这里不对，verifier不应该知道 u 和 ru
        transcript.get_and_append_challenge_vectors(b"u", proof.z.len()).unwrap();
        transcript.get_and_append_challenge(b"ru").unwrap();

        transcript.append_serializable_element(b"cm", &proof.cm.0).unwrap();
        transcript.append_serializable_element(b"U", &proof.U);
        let c = transcript.get_and_append_challenge(b"c").unwrap();

        let lhs = proof.U + proof.cm.0.mul(c);
        let msm = C::msm(&params.generators, &proof.z).unwrap();
        let rhs = params.h.mul(proof.rz) + msm;
        if lhs != rhs {
            return false;
        }
        true
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use ark_std::UniformRand;
    use ark_secp256k1::{Fr, Projective};

    #[test]
    fn test_schnorr() {
        let mut rng = ark_std::test_rng();

        let max = 10;
        let params = Schnorr::new_params(&mut rng, max);

        let mut transcript_p = IOPTranscript::<Fr>::new(b"schnorr_test");
        transcript_p.append_message(b"init", b"init").unwrap();

        let mut transcript_v = IOPTranscript::<Fr>::new(b"schnorr_test");
        transcript_v.append_message(b"init", b"init").unwrap();

        let m = vec![Fr::rand(&mut rng); max];
        let r = Fr::rand(&mut rng);

        let proof = Schnorr::<Projective>::prove(&params, &mut transcript_p, &m, &r);
        assert!(Schnorr::<Projective>::verify(&params, &mut transcript_v, &proof));
    }
}